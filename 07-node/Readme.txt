1，node:称之为 node; nodejs; node.js都是OK的
   前端：前端开发脱离不了node 
   应用： 
       作为前端的工具  一般来说都是脚手架  npm
       作为服务端的runtime  运行的还是js代码
       作为中间层：用来解决跨域问题；过滤后端数据得到需要的；
       作为SSR：服务端渲染（让服务器将页面封装好）php java不可进行服务端渲染；  之前使用json来传送数据，不利于SEO优化，爬虫
   后端：相当于Java,php,python,go...，可用来开接口

2，js代码的运行环境：
   浏览器：它作为js代码的运行环境，里面跑着vue,react,js,dom（操作dom三大方法ES,BOM,DOM）这些语言
   node环境：它不能操作DOM元素，只能运行ES代码，操作数据库，操作文件，node不是一门编程语言，仅仅是基于V8引擎（用来解析js代码）的js运行环境，和浏览器一样，只是用来运行js代码的

3，谷歌浏览器：v8引擎，用来解析js代码；node也是基于v8引擎的

4，node的特点：
   1) 创建高性能的web服务器：基于v8引擎
   2) IO密集：Input  Output  操作输入输出比较厉害    cpu密集：计算非常牛  Java
   3) Input Output例子：请求api接口，操作数据库，操作文件
   4) 单线程：js的主线程是单线程  可以ajax请求 setTimeout()异步任务是多线程的
        客户端请求Java后端时，是多线程的，它会产生线程池的概念，非常消耗资源，多线程会产生锁，但也会造成死锁。
        客户端请求node后端时，主线程并不会一直处理这个请求，它会通过某种机制，让node先处理着这个请求，主线程会继续处理别的客户端，如果node后端处理完了，通知主线程，主线程会返回第一个请求，它是靠异步解决的：回调函数;事件机制;promise;generrator+co;async+await
   5) 高并发：多个客户端可同时请求node后端，虽然是单线程，但仍然OK，可以处理高并发
   6) 异步非阻塞：不会浪费时间，在那里白白等待
   7) 基于事件驱动
   8) npm（很多包）属于第三方模块

5，node中的模块 
  1) 内置模块，系统本身的模块，又成为核心模块
     模块引入：直接require  require("path")
  2) 第三方模块（安装的包，依赖）
     模块引入：直接require  require("element-ui")
  3) 自定义模块
     模块引入：需要以./打头  require("./myXXX")
6，浏览器事件环，node事件环必备知识
   （1）进程与线程
        1) 进程：进程是操作系统分配和调度资源（CPU和内存）的基本单位。进程有自己独立的地址空间，一个进程挂掉是不会影响其他进程的。
        2) 线程：线程是程序执行的基本单位，每一个选项卡就是一个进程，真正干活的是线程，多线程的程序只要有一个线程挂掉了，整个进程也就死掉了。
   （2）同步与异步：同步 异步 阻塞 非阻塞
        1) 同步，异步针对的是被调用者：
            同步的话会导致阻塞，但它会立即获得结果；同步阻塞
            异步的话造成非阻塞，它不能立即得到结果。异步非阻塞
        2) 阻塞，非阻塞针对调用者
            阻塞的话不会立即得到结果；
            非阻塞的话是立即得到结果。
   （3）队列与栈
        1) 队列,堆(heap)：也可称为堆内存，它里面存放着基本数据类型，会自动分配内存空间。是一种队列优先，先进先出的数据结构
        2) 栈(stack):又名'堆栈'，它里面存放着引用数据类型，会动态分配内存空间，大小不定也不会自动释放。也是一种数据结构，不过它是按照先进后出的原则存储数据的
   （4）浏览器模型：用户界面-->浏览器引擎（数据存储）-->渲染引擎-->js解析，UI渲染，网络请求

7，浏览器的事件环：事件环运行机制就是执行栈中的内容。
   异步任务：
   注意点：promise.then是异步任务的微任务，而promise却是同步任务
        宏任务（macrotask）：setImmediate(IE支持，但node中自己实现了)   setTimeout  setInterval  
        微任务（microtask）：promise.then() process.nextTick(node的)
   栈中有同步任务（1）先执行同步任务(在栈中)；
                （2）再执行异步任务(任务队列)中的微任务，将微任务清空；
                （3）再执行宏任务；
                    1）取出一个宏任务；
                    2）在执行宏任务时，有微任务，清空微任务
                    3）再去执行新的宏任务

8，node是基于v8引擎的运行环境，在处理高并发、I/O密集(文件操作、网络操作、数据库操作等)场景有明显的优势。node的事件环机制与浏览器的是不太一样，然而在node11.x版本以后，node事件环就慢慢和浏览器事件环一样了。

9，js中的全局对象：global
      浏览器全局对象：window  var a = 110  它是挂载在window上的全局变量  window.a
      node全局对象：global

10，global中的内容：
        exports   module require  __dirname  _filename  可直接使用，不需要使用global.  它们都位于global上
        process  进程，表示着当前的运行环境
        Buffer   缓存，内存中的数据（二进制数据）
        setTimeout (浏览器中属于window  node中属于global)  clearTimeout
        setImmediate  clearImmediate
        setInterval   clearInterval
        console

11，path模块有很多方法：basename  extname  dirname  join  resolve
   1) path.basename() 返回的是path的最后一部分  拿到文件前面的文件名
   2) path.extname() 得到的是文件的拓展名，从最后一次出现.字符到path最后一部分字符串结束
   3) path.dirname()  返回path的目录名  而其尾部的目录分隔符 / 会被忽略
   4) path.join() 会将所有给定的path拼接到一起，然后规范生成的路径
   5) path.resolve() 将路径或路径片段的序列解析为绝对路径；如果没有传入 path 片段，则返回当前工作目录的绝对路径。
应用：在服务器端，路径尽量使用绝对路径。学习使用path模块，目的就是为了得到绝对路径

12，node.js可以用来处理二进制流数据或者与之进行交互，它靠的就是Buffer(用于读取或操作二进制数据流)和stream

13，Buffer详解：
    1) Buffer概念：它相当于构造器，是一个类，不需要require，直接new即可，主要用于读取或操作二进制数据流
    2) 创建Buffer：Buffer就是一个内存空间，创建后就直接放数据。
       Buffer.from()  开辟一块内存将数据扔进去
       Buffer.alloc() 开辟一块内存，里面没有垃圾数据，是干净内存块
       Buffer.allocUnsafe()  只管开辟一块内存，分配空间，里面有垃圾数据
      buffer相关有两种：一种是从磁盘里读取数据放到内存（buffer）里面；另一种是在内存里开辟一块内存空间(buffer)，在里面写数据
    3) 操作buffer的api：它们是一堆的方法
       copy:将小的buffer放到大的buffer上面去 它是buffer缓存区的方法 
       concat:将小buffer合并成大的buffer 它的参数应为数组形式

14，异步：
    异步流程：回调函数--->promise---->generator+co---->async+await
    （1）promise:答应，承诺的意思  结果不会立即得到    将promise与函数调用相比会更加优雅
         利用promise主要解决：并发问题；链式调用问题；如果不存在promise，之前全部靠回调函数，而回调会产生回调地狱。
         1) Promise是一个类，使用之前需要new，在new时需要给其传递一个执行器executor()=>{}，这个执行器会立即执行，在执行器中有两个参数：resolve，reject；二者都是函数，就可以将promise从等待态pending到成功态success或者说失败态failed
         2) promise有一个then方法，如果是成功态，它会调用then中的第一个函数；为得到成功的终值结果，data就成为第一个函数的参数；如果失败的话，就调用then中的第二个函数；为得到失败的原因，err就成为第二个函数的参数。
               如若在promise中扔出一个错误的话，那么也就代表着失败啦  
        3) promise存在三种状态：pending,rejected,resolved		   
        4) promise的状态只能从等待态到成功 或者 从成功到失败，不可能出现两种结果  
        4）改变状态的方法：成功态：resolve函数，失败态：reject或者扔出一个错误
        5) promise中有异步，在执行器内部可以写异步代码，也就是异步操作。比如：setTimeout,setInterval...
        6) promise链式调用问题，首先是读取文件本身是异步操作，为解决它使用promise，封装一个函数来读取文件，那么函数调用时直接.then就代表着函数内部有promise
           最终却又再次出现回调地狱，为解决它，使用promise链式调用，.then之后又是一个新的promise，可再次.then。
           如果在封装完函数，进行函数调用时返回的是promise，那么这个promise会执行，并且会采用其状态，也就是说接下来的.then将会是这个返回值promise的
         链式调用：如果在上一个then的第一个函数中返回的是一个普通值，会走到下一个then的第一个函数，return的这个普通值作为这个then的data；如果返回的是一个promise，会作为promise对象，接下来的then中的data和err都去promise对象中取。
         7) promise的递归解析表示，如果在resolve或者reject中又嵌套promise，会发生递归解析的，也就是将所有promise解析完毕，再进行赋值
         8) promise的catch方法：
            1，如果.then中有第2个函数err，在这个.then后面又有catch，如果到失败态，它会走.then的第2个函数
            2，如果.then中没有第2个函数err，在这个.then后面又有catch，如果到失败态，它会走catch
            3，如果在.then的第二个函数中，return err的话，这个err会return到下一个.then的data函数中
            4，在promise中，一般在then中只有一个函数data，在.then后面有一个catch，一般使用.then来获取data，在catch中获取err
         9) promise的静态方法：
           1，resolve和reject方法，都可直接调用使用.运算符
           2，finally就是最终的意思，不管转成成功态还是失败态，都会调用finally这个方法
           3，all表示[]中的promise对象都成功之后才会得到终值  在读取文件时要想将其变为promise的那种读法，在这个api上只需.promises
           4，race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。
     （2）generator+co: 
          generator代表生成器，它是ES6中的语法，生成器构建时需要在function和要写函数之间加上*可以挂在function或者函数上，也可位于两者之间
          迭代器可通过生成器调用生成，迭代器可以让程序中断，它并不会把{}中的代码全部执行
         1) 生成器可直接产出好多值，迭代器只能next一下，拿到一值，next一下，拿到一值
         2) 在生成器中如果出现let a 这种声明时，或者console.log()时，它都需要传递参数，最终的打印出来的值也都是传递过来的参数
         3) 在next时传递参数时，第一个next的参数无任何意义，是无用功。
         4) 进行生成器，迭代器不断操作时再次出现回调地狱，解决方法，就是利用co库，使用co将生成器调用一次然后.then就可拿到结果
     （3）async+await:
         它的使用方法与上面相似，但不需要引入第三方模块，将原来的yiled换成await，在之前生成器前加上async 去掉原本生成器之间的*，调用时也是直接调用函数然后.then。   

15，高阶函数：
    高阶函数主要可分为两类：
           第1种：这个函数中的参数是函数；
           第2种：这个函数的返回值是函数。
   1，before函数(装饰函数，AOP)，before函数返回值是一个函数，在执行一个函数之前去执行另一个函数 
      注意点：
             1) 在执行的那个普通函数上不存在before那个函数，需要在函数原型上去构建；
             2) 构建的函数，因为before函数返回值是一个函数，那么构建的这个函数的返回值也应为函数；
             3) 在before函数中除了调用before返回函数外，还会调用普通函数，利用this()
             4) 在调用before返回函数时可传递参数，利用...rest参数来接收，它可不断向下传递，传给f1
   2，after函数，调用一个函数n次后，触发另一个函数那就利用after函数          
      注意点：
             1) after函数返回值是一个函数，那么在其执行器中return的是一个函数
             2) after有两个参数，一个是函数执行次数要满足的条件，第二个就是满足次数后要的调用的函数
   3，包括函数：在执行某个函数之前执行若干个函数，在执行某个函数之后执行若干个函数，又称事务函数
      注意点：
             1) 因为不管是执行某函数之前还是之后，都要执行若干个函数，需要把这些函数存储起来，存放到对象里面
             2) 存放这些函数的对象可以有多个，将多个对象可放在数组当中，要想得到每个对象中的函数进行遍历。
   4，发布订阅：
      1) 一般情况下是先发布后订阅，但实际上两者并未有啥关系； 可将它想成按钮的点击事件，在点击之前仅仅是订阅，点击事件发生的同时就是发布啦
      2) 订阅时可以有多个订阅事件函数，我们可将其存放push到容器数组中，在发布时，再将它们遍历出来，并执行订阅函数操作
   5，观察者模式：观察者模式可分为观察者和被观察者（被观察者中存放着观察者） 两者是有关系的 

16，事件与流：
     事件：node是基于事件驱动的  导入events模块
     流：可分为可读流与可写流 
         在http协议创建服务器时，req是请求，是一个可读流
         在http协议创建服务器时，res是响应，是一个可写流

17，http协议：http协议就是计算机与计算机进行交流遵循的规则
    （1）请求：主要包含三个部分
      请求行：里面存在  方法  路径  协议
      请求头：可以浏览器添加；或者自己添加
      请求正文：给服务器的数据
    （2）响应：主要包含三个部分
       状态码：主要有以下几类：以2开头-->到3-->再到4,5
               200 请求成功了
               301 永久重定向 
               302 临时重定向 
               304 缓存
               404 服务器找不到请求的资源  
               401 无仅限访问
               500 服务器挂了
       响应头：一堆的头
       响应正文：服务器给你响应的真实数据
   req请求中可以解析得到url，对于前端的路由：一个url代表一个组件；后端的路由：一个url对应一个资源。
   因为每次改变服务器代码都要求重启服务器，可安装一个模块，叫nodemon，修改完代码后，会自动重启
   安装：> npm i nodemon -g
   使用：> nodemon 文件名

18，node框架：express  koa  基于koa进行二次封装
Express学习:
  1，Express概念：
        Express是基于Node.js平台，快速、开放、极简的web开发框架；web可分两类：做管理系统与开接口   
  2，Express路由:
      官方概念：路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。
      民间概念：给一个请求，这个请求交给谁来处理，交给的过程就是路由
      1) express中实现路由的方式：
            针对应用级别的路由，在app对象上进行创建；
            针对router实例对象的路由，在router对象上进行创建；
      2) 创建一个针对应用级别的路由，是分步骤：
            a, 通过express()创建一个app实例
            b, METHOD是一个HTTP的请求方法，如get请求或post请求， app.get(), app.post()
            c, 第一个参数path是服务器上的路径，是url中的路径部分，如 “/”  “/user”
            d,第二个参数callback，当路由匹配成功是要执行一个函数，在这个函数中有两个非常重要的参数，req，res,  req是指incommingMessage, res是指serverResponse
      3) 路由方式（主要）：
         get:直接输入网址；href；src；表单form(method = get)
         post：表单form(method = post)
      4) 路由句柄:路由句柄就是一个回调函数，它存在两个参数：req（incommingmessage）它表示请求信息我们只能获取，不能修改；res（serverResponse）它表示响应对象，可以做服务器上的任何事情。
           特点：
            （1）对于一个路由句柄（可以理解为callback），可以设置多个
            （2）当我们设置两个回调函数时，第二个回调函数并未起作用
            （3）如果想要让第二个回调函数起作用，要用到第三个参数next，需要在第一个回调函数里调用next()
      5) 回调函数参数：在express中的回调函数参数是在原生node的基础上进行再次封装，增加了新的属性和方法
         req：是作为回调函数的第一个参数
           （1）req中的属性query可以将查询字符串变成对象
           （2）req中的属性path可以得到路径名
         res：是作为回调函数的第二个参数
            （1）res的send方法直接发送响应的内容，可以是普通字符串，也可以是html标签，不需要写其它的头信息
            （2）res的sendFile方法可用来发送文件，我们可以用来发送一个html文件（里面存在css,js...），它使用时利用__dirname需要拼接上文件路径
            （3）res的json方法可以用来发送一个json格式的数据，就是将发过来的数据都转成json格式，全部加上""
            （4）res的redirect方法进行重定向，和之前vue中路由重定向相似
            （5）res的render方法，它需要将依赖，包都要引进来，它是去渲染views视图中的模板，从而用来做系统
  3，Express中间件：
       中间件可以想成是回调函数，在每个回调函数中，存在3个参数，req,res,next。和路由句柄有相似之处
       Express是一个自身功能极简，完全是由路由和中间件构成一个web开发框架；本质上一个Express应用就是在调用各种中间件
     （1）中间件可以做什么？
        执行任何代码
        修改请求和响应对象
        终结请求—响应循环
        调用堆栈中的下一个中间件
     （2）express中有哪些中间件？
         应用级中间件：通过app对象来调用
         路由级中间件：是指要利用express.Router对象来调用
         错误处理中间件：它存在四个参数，多了个err，它需要在next函数中扔出一个错误，那么就会走下面的错误函数
         内置中间件：express.static 负责托管静态资源的，也就是用来载入静态资源的
         第三方中间件：真正开发时使用，主要好用的有：body-parser,cookie-parse,express-session
     （3）应用级别中间件的使用：
           格式：app.use([path],callback);
           path是可不写的，这时它就说明所有的请求都会使用这个中间件，相当于路径为*    
    注意点：
    （1）在访问一个路由时会先访问其中间件，要想继续向下访问的话就要求next一下 
    （2）每个路由都有其对应的中间件，中间件也只会控制对应的路由。比如 /XXX这个路由，它会有至少走两个中间件，一个是/ 一个是/XXX
    （3）中间件在执行时是有顺序的，谁在前就先执行谁
  4，应用生成器：脚手架
    1) 创建项目流程：
      （1）安装：npm install -g express-generator
      （2）创建应用：express my -->进入项目：cd  myXXX-->安装依赖: npm install
      （3）启动项目：npm start
    2) 项目结构分析：
      （1）bin中都是存放的可执行文件  www在它里面创建了一个默认端口为3000的服务器
      （2）node_modules中都是一个模块或者包
      （3）public中存放着一些静态资源。如imgs,js,css等
      （4）routes存放的是一些路由相关文件，有二级路由
      （5）views中存放着视图文件，都是一些模板，而在express中默认使用的是jade模板引擎，我们之前所说的html是ejs模板引擎，想要改变的话，可以在创建项目时加上-e
      （6）app.js是项目入口文件
      （7）package.json是项目的描述文件，里面存放着项目所需的第三方模块或者依赖
  5，渲染分类：
    1) 服务器渲染：服务器把真实数据渲染到views的模板里面，然后给客户端返回的就是一个真实数据，是渲染完毕的内容数据又称SSR
    2) 客户端渲染：使用vue去请求api接口得到json数据，利用v-for将数据渲染出来
    3) 前后端分离的基本都是客户端渲染，利用axios拿到数据在vue react中渲染数据
    4) jsp  php  .net  做一个管理系统  都属于客户端渲染  后端利用views视图文件中的模板引擎来将真实数据渲染出来

Koa学习：
  1，Koa概念：
       Koa是一个新的web框架，由Express幕后的原班人马打造，致力于成为web应用和API开发领域中的一个更小、更富有表现力、更健壮的基石。
       通过利用async函数，Koa帮你丢弃回调函数，并有力地增强错误处理。Koa并没有捆绑任何中间件，而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。
  2，Koa实例上也有很多方法属性:koa建议使用koa封装的
      1) 原生res,req指的是node上的，它也可在koa中访问，需要ctx.res.xxx或者ctx.req.xxx
      2) koa封装了两个属性response和request，它想要访问其上面的方法属性要求ctx.response.xxx或者ctx.request.xxx
      3) 对于原生的req存在的属性有url，却没有path这个属性，它只存在pathname，那也仅仅是通过url解析得到的和res上存在end方法但没有send方法，send方法是express上的，在koa上没有
      4) 对于封装的属性request上存在url和path两个属性和response上面也存在end方法，但没有send方法。它们在访问时可通过直接访问这上面的方法或者去拿原生上的对应方法
      5) 封装的属性上还有一个比较特殊的body,它是以赋值的形式将响应内容展示出来。ctx.response.body=xxx  代表响应内容   
      6) 在koa中的最简访问形式  ctx.body = xxx  响应内容  ctx.url  得到网址  ctx.path  得到路径
  3，Koa中间件：
        在koa中没有路由默认情况下它会匹配到/，你要使用路由的话就要使用第三方的Koa中间件
      小细节：
        1) 在koa中与express是一样的，中间件都是从上向下的执行的
        2) 在koa中，在一个中间件中调用next()  表示让下一个中间件执行
        3) koa中间件原理就是洋葱模型：就是在调用时将每个next()换成下一个中间件，这样函数执行内容会发生变化。
  4，koa中间件原理：
     1) dispatch函数:来判断执行容器中的哪一个方法，在存在next时要求调用下一个中间件
          首先会定义一个对象，里面有use这样一个方法，因为实际中use方法里的函数不会立即调用，所以在对象中的方法里会将函数全部推到一个容器里面，然后定义一个函数去执行容器里的方法函数；当存在next函数时，那么会在前面函数中传递参数，再次调用dispatch
  5，Koa常见中间件：koa-views  koa-static  koa-router  koa-compose  koa-bodyparser
     中间件本质上就是函数，当中间件中出现异步操作时，会破坏之前koa的洋葱模型
     在中间件我们调用的next函数返回promise，它是一个异步函数，那么可将async和await配合使用来解决异步，而它们也仅仅是将promise状态转成普通数值而已，在遇见异步操作仍是没有啥变化，也没改变，等待异步的执行。
     koa常见中间件（都是第三方模块）  -----> 查看第三方模块咋用的地方--->npm    github



现在只需要知道什么是数据库，什么是集合，什么文档，怎么创建数据库，怎么创建一个集合，怎么创建一个文档，就行，下午写案例时，在案例中使用mongo，会再好一点


利用koa2脚手架创建项目：
 创建项目步骤：
     第一步：npm i koa-generator -g
     第二步：koa2 mycms
     第三步：cd mycms
     第四步：npm install
     第五步：npm start
 创建的项目包含：
     前端：创建前端的入口路由文件
     后台：创建后台的入口路由文件
     api接口：创建api接口的入口路由文件

鉴权：
  cookie原理：cookie里面存放的是键值对，是浏览器端用来存储数据的一片区域，用来存储数据。当访问一个服务器时，服务器会给浏览器返回一堆信息，这一堆信息存放在cookie中，服务器给浏览器种植cookie。
             当你再去请求服务器时，会带着一堆的cookie（一堆信息）  每次请求都会带上cookie，占带宽，不安全
  session原理：存储数据，只是数据存储在服务器，session是基于cookie的，cookie中保存着服务器返回给浏览器的session_id，而非一堆数据信息，在以后的每次请求，都需要带着session_id
  jwt主要靠token     vue时会返回token  Local Storage  



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
新的难点：jsonp  它是跨域的解决方案之一
  json就是客户端与服务器之间传输数据的数据格式
  跨域的解决方案：8-9种方案  （面试必备）
    1，使用代理：浏览器跨域，（前端代码）可以在本地开启一个服务去请求数据
    2，Cors 服务器端来配置别人来任意访问  （后端代码）
    3，Jsonp （前后端代码都需要动）
    4，Webpack  
1，什么是jsonp？   
  jsonp：json with packing的简写形式，将json数据包装起来并返回的一种方式---协议。利用这种协议就可以解决跨域
         在使用jsonp实现跨域的时候，它是需要将json数据作为函数的参数，最终在服务端将包装好的字符串作为结果返回给浏览器端

2，json与jsonp的区别？
   json是字符串，是数据；jsonp是协议，是传递json数据的方式

3，jsonp的使用场景？
 在使用jsonp的时候，需要确保：
    有权限去编写服务端的代码（你有权利去改变后端的代码）
    在浏览器端也需要写一些代码 （还需要有资格去动前端的代码）

4，跨域问题的几种类型：协议，域名，端口有一个不一样就会产生跨域
   第一种：直接复制文件路径，去打开文件；它们协议不一样  它走的是file协议
         服务器：http://localhost:3000/newslist
         客户端：file:///C:/Users/kanghuanying/Desktop/jsonp/1,jsonp%E8%B7%A8%E5%9F%9F%E4%B9%8Bbower.html
   第二种：使用插件，直接open with live Server，vscode开启一台服务；它们端口不一样
          服务器：http://localhost:3000/newslist
          客户端：http://127.0.0.1:5500/1,jsonp%E8%B7%A8%E5%9F%9F%E4%B9%8Bbower.html
   第三种：自己写一个express服务，获取数据；它们是因为端口不一样
          服务器：http://localhost:3000/newslist
          客户端：http://localhost:4000/   

5，解决跨域：
   datatype:json--->转成jsonp形式  出现语法错误（不想要让它报错，就需要服务器返回一个函数调用的字符串）  但实际上数据已经响应回来了
   jsonp使用：后端代码与前端代码都需要动
   服务器：http://localhost:3000/newslist
   客户端：如果是jsonp请求，那么会在请求的地址后面加上callback
         http://localhost:3000/newslist?callback=jQuery111304242870793902809_1566875161688&_=1566875161689
  
   在请求数据是datatype是json时会有跨域限制，在使用jsonp时就可以得到数据，客户端会在请求的url后面加上callback
   jsonp请求回来返回得到的数据是一个json字符串，不是包装好的jsonp协议的字符串，但是在浏览器端是按照jsonp的协议来解析这个结果的，所以出现语法错误。
   jsonp返回的不能是json字符串，必须是函数调用的字符串，将返回的json数据作为函数的参数
   前端想要经过jsonp包装后的数据，那么需要把数据作为函数调用的参数

6，小总结：
   1）前端与后端如果不在同一域下，会有跨域限制。
      解决方案：前端接收数据使用jsonp的形式接收，如果使用jsonp形式接收，请求的url后面会加上callback=“XXX”
            后端要返回一个函数调用，函数名可以通过req.query.callback得到，把数据作为函数实参

   2）在使用jq的ajax方法实现jsonp跨域，必须：
        在浏览器端，设置datatype为jsonp；
        在服务器端，必须以函数调用json字符串的形式返回作为字符串返回
      let cb = req.query.callback   得到函数名
      res.send(cd+"("+JSON.stringfy{数据内容}+")")
   3）在express中，针对jsonp格式的返回，专门封装了一个jsonp方法：res.jsonp({数据内容})
      express的语法糖：res.jsonp({数据内容})
      当后端返回的数据是：res.jsonp({code:"1",msg:"xxx"})，前端要想得到数据，需要声明我接受的数据类型是jsonp形式的，在jq中声明是通过：datatype：jsonp来声明

7，jsonp的原理
 跨域条件：1，ajax(axios) + 在浏览器发出请求；2，协议，端口，域名不一样
 1）jsonp解决跨域，并不是ajax发出的请求（XHR），所以它也就不存在跨域
 2）jsonp是script中的src发出的请求，src发出的二次请求没有跨域限制 
    当在一个网址中出现src，href这些会发出二次请求
 3）jsonp的实现是通过动态的添加script标签，利用src发送http请求来实现的，前端会传一个callback回去，后端会将数据作为callback实参进行函数调用
   不再利用ajax来发出请求，使用script标签中的src发出请求，首先需要创建一个script标签，标签里有地址，地址请求服务器，将需要请求的内容通过src请求回来，然后服务器将请求回来的内容给了浏览器，浏览器将内容渲染出来


传递id：如果是get请求，可以通过在路径后面添加？id="XXX"的形式
        如果是post请求，要求使用隐藏框<input type="hidden" name="id" value="{{list._id}}">仅仅用来传值



























































