1，node:称之为 node; nodejs; node.js都是OK的
   前端：前端开发脱离不了node 
   应用： 
       作为前端的工具  一般来说都是脚手架  npm
       作为服务端的runtime  运行的还是js代码
       作为中间层：用来解决跨域问题；过滤后端数据得到需要的；
       作为SSR：服务端渲染（让服务器将页面封装好）php java不可进行服务端渲染；  之前使用json来传送数据，不利于SEO优化，爬虫
   后端：相当于Java,php,python,go...，可用来开接口

2，js代码的运行环境：
   浏览器：它作为js代码的运行环境，里面跑着vue,react,js,dom（操作dom三大方法ES,BOM,DOM）这些语言
   node环境：它不能操作DOM元素，只能运行ES代码，操作数据库，操作文件，node不是一门编程语言，仅仅是基于V8引擎（用来解析js代码）的js运行环境，和浏览器一样，只是用来运行js代码的

3，谷歌浏览器：v8引擎，用来解析js代码；node也是基于v8引擎的

4，node的特点：
   1) 创建高性能的web服务器：基于v8引擎
   2) IO密集：Input  Output  操作输入输出比较厉害    cpu密集：计算非常牛  Java
   3) Input Output例子：请求api接口，操作数据库，操作文件
   4) 单线程：js的主线程是单线程  可以ajax请求 setTimeout()异步任务是多线程的
        客户端请求Java后端时，是多线程的，它会产生线程池的概念，非常消耗资源，多线程会产生锁，但也会造成死锁。
        客户端请求node后端时，主线程并不会一直处理这个请求，它会通过某种机制，让node先处理着这个请求，主线程会继续处理别的客户端，如果node后端处理完了，通知主线程，主线程会返回第一个请求，它是靠异步解决的：回调函数;事件机制;promise;generrator+co;async+await
   5) 高并发：多个客户端可同时请求node后端，虽然是单线程，但仍然OK，可以处理高并发
   6) 异步非阻塞：不会浪费时间，在那里白白等待
   7) 基于事件驱动
   8) npm（很多包）属于第三方模块

5，node中的模块 
  1) 内置模块，系统本身的模块，又成为核心模块
     模块引入：直接require  require("path")
  2) 第三方模块（安装的包，依赖）
     模块引入：直接require  require("element-ui")
  3) 自定义模块
     模块引入：需要以./打头  require("./myXXX")
6，浏览器事件环，node事件环必备知识
   （1）进程与线程
        1) 进程：进程是操作系统分配和调度资源（CPU和内存）的基本单位。进程有自己独立的地址空间，一个进程挂掉是不会影响其他进程的。
        2) 线程：线程是程序执行的基本单位，每一个选项卡就是一个进程，真正干活的是线程，多线程的程序只要有一个线程挂掉了，整个进程也就死掉了。
   （2）同步与异步：同步 异步 阻塞 非阻塞
        1) 同步，异步针对的是被调用者：
            同步的话会导致阻塞，但它会立即获得结果；同步阻塞
            异步的话造成非阻塞，它不能立即得到结果。异步非阻塞
        2) 阻塞，非阻塞针对调用者
            阻塞的话不会立即得到结果；
            非阻塞的话是立即得到结果。
   （3）队列与栈
        1) 队列,堆(heap)：也可称为堆内存，它里面存放着基本数据类型，会自动分配内存空间。是一种队列优先，先进先出的数据结构
        2) 栈(stack):又名'堆栈'，它里面存放着引用数据类型，会动态分配内存空间，大小不定也不会自动释放。也是一种数据结构，不过它是按照先进后出的原则存储数据的
   （4）浏览器模型：用户界面-->浏览器引擎（数据存储）-->渲染引擎-->js解析，UI渲染，网络请求

7，浏览器的事件环：事件环运行机制就是执行栈中的内容。
   异步任务：
   注意点：promise.then是异步任务的微任务，而promise却是同步任务
        宏任务（macrotask）：setImmediate(IE支持，但node中自己实现了)   setTimeout  setInterval  
        微任务（microtask）：promise.then() process.nextTick(node的)
   栈中有同步任务（1）先执行同步任务(在栈中)；
                （2）再执行异步任务(任务队列)中的微任务，将微任务清空；
                （3）再执行宏任务；
                    1）取出一个宏任务；
                    2）在执行宏任务时，有微任务，清空微任务
                    3）再去执行新的宏任务

8，node是基于v8引擎的运行环境，在处理高并发、I/O密集(文件操作、网络操作、数据库操作等)场景有明显的优势。node的事件环机制与浏览器的是不太一样，然而在node11.x版本以后，node事件环就慢慢和浏览器事件环一样了。

9，js中的全局对象：global
      浏览器全局对象：window  var a = 110  它是挂载在window上的全局变量  window.a
      node全局对象：global

10，global中的内容：
        exports   module require  __dirname  _filename  可直接使用，不需要使用global.  它们都位于global上
        process  进程，表示着当前的运行环境
        Buffer   缓存，内存中的数据（二进制数据）
        setTimeout (浏览器中属于window  node中属于global)  clearTimeout
        setImmediate  clearImmediate
        setInterval   clearInterval
        console

11，path模块有很多方法：basename  extname  dirname  join  resolve
   1) path.basename() 返回的是path的最后一部分  拿到文件前面的文件名
   2) path.extname() 得到的是文件的拓展名，从最后一次出现.字符到path最后一部分字符串结束
   3) path.dirname()  返回path的目录名  而其尾部的目录分隔符 / 会被忽略
   4) path.join() 会将所有给定的path拼接到一起，然后规范生成的路径
   5) path.resolve() 将路径或路径片段的序列解析为绝对路径；如果没有传入 path 片段，则返回当前工作目录的绝对路径。
应用：在服务器端，路径尽量使用绝对路径。学习使用path模块，目的就是为了得到绝对路径

12，node.js可以用来处理二进制流数据或者与之进行交互，它靠的就是Buffer(用于读取或操作二进制数据流)和stream

13，Buffer详解：
    1) Buffer概念：它相当于构造器，是一个类，不需要require，直接new即可，主要用于读取或操作二进制数据流
    2) 创建Buffer：Buffer就是一个内存空间，创建后就直接放数据。
       Buffer.from()  开辟一块内存将数据扔进去
       Buffer.alloc() 开辟一块内存，里面没有垃圾数据，是干净内存块
       Buffer.allocUnsafe()  只管开辟一块内存，分配空间，里面有垃圾数据
      buffer相关有两种：一种是从磁盘里读取数据放到内存（buffer）里面；另一种是在内存里开辟一块内存空间(buffer)，在里面写数据
    3) 操作buffer的api：它们是一堆的方法
       copy:将小的buffer放到大的buffer上面去 它是buffer缓存区的方法 
       concat:将小buffer合并成大的buffer 它的参数应为数组形式

14，异步：
    异步流程：回调函数--->promise---->generator+co---->async+await
    （1）promise:答应，承诺的意思  结果不会立即得到    将promise与函数调用相比会更加优雅
         利用promise主要解决：并发问题；链式调用问题；如果不存在promise，之前全部靠回调函数，而回调会产生回调地狱。
         1) Promise是一个类，使用之前需要new，在new时需要给其传递一个执行器()=>{}，这个执行器会立即执行，在执行器中有两个参数：resolve，reject；二者都是函数，就可以将promise从等待态pending到成功态success或者说失败态failed
         2) promise有一个then方法，如果是成功态，它会调用then中的第一个函数；为得到成功的终值结果，data就成为第一个函数的参数；如果失败的话，就调用then中的第二个函数；为得到失败的原因，err就成为第二个函数的参数。
               如若在promise中扔出一个错误的话，那么也就代表着失败啦
         3) promise的状态只能从等待态到成功 或者 从成功到失败，不可能出现两种结果
         4) promise中有异步，在执行器内部可以写异步代码，也就是异步操作。比如：setTimeout,setInterval...
         5) promise链式调用问题，首先是读取文件本身是异步操作，为解决它使用promise，封装一个函数来读取文件，那么函数调用时直接.then就代表着函数内部有promise
           最终却又再次出现回调地狱，为解决它，使用promise链式调用，.then之后又是一个新的promise，可再次.then。
           如果在封装完函数，进行函数调用时返回的是promise，那么这个promise会执行，并且会采用其状态，也就是说接下来的.then将会是这个返回值promise的
         链式调用：如果在上一个then的第一个函数中返回的是一个普通值，会走到下一个then的第一个函数，return的这个普通值作为这个then的data；如果返回的是一个promise，会作为promise对象，接下来的then中的data和err都去promise对象中取。
         6) promise的递归解析表示，如果在resolve或者reject中又嵌套promise，会发生递归解析的，也就是将所有promise解析完毕，再进行赋值
         7) promise的catch方法：
            1，如果.then中有第2个函数err，在这个.then后面又有catch，如果到失败态，它会走.then的第2个函数
            2，如果.then中没有第2个函数err，在这个.then后面又有catch，如果到失败态，它会走catch
            3，如果在.then的第二个函数中，return err的话，这个err会return到下一个.then的data函数中
            4，在promise中，一般在then中只有一个函数data，在.then后面有一个catch，一般使用.then来获取data，在catch中获取err
         8) promise的静态方法：
           1，resolve和reject方法，都可直接调用使用.运算符
           2，finally就是最终的意思，不管转成成功态还是失败态，都会调用finally这个方法
           3，all表示[]中的promise对象都成功之后才会得到终值  在读取文件时要想将其变为promise的那种读法，在这个api上只需.promises
           4，race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。
     （2）generator+co: 
          generator代表生成器，它是ES6中的语法，生成器构建时需要在function和要写函数之间加上*可以挂在function或者函数上，也可位于两者之间
          迭代器可通过生成器调用生成，迭代器可以让程序中断，它并不会把{}中的代码全部执行
         1) 生成器可直接产出好多值，迭代器只能next一下，拿到一值，next一下，拿到一值
         2) 在生成器中如果出现let a 这种声明时，或者console.log()时，它都需要传递参数，最终的打印出来的值也都是传递过来的参数
         3) 在next时传递参数时，第一个next的参数无任何意义，是无用功。
         4) 进行生成器，迭代器不断操作时再次出现回调地狱，解决方法，就是利用co库，使用co将生成器调用一次然后.then就可拿到结果
     （3）async+await:
         它的使用方法与上面相似，但不需要引入第三方模块，将原来的yiled换成await，在之前生成器前加上async 去掉原本生成器之间的*，调用时也是直接调用函数然后.then。   

15，高阶函数：
    高阶函数主要可分为两类：
           第1种：这个函数中的参数是函数；
           第2种：这个函数的返回值是函数。
   1，before函数(装饰函数，AOP)，before函数返回值是一个函数，在执行一个函数之前去执行另一个函数 
      注意点：
             1) 在执行的那个普通函数上不存在before那个函数，需要在函数原型上去构建；
             2) 构建的函数，因为before函数返回值是一个函数，那么构建的这个函数的返回值也应为函数；
             3) 在before函数中除了调用before返回函数外，还会调用普通函数，利用this()
             4) 在调用before返回函数时可传递参数，利用...rest参数来接收，它可不断向下传递，传给f1
   2，after函数，调用一个函数n次后，触发另一个函数那就利用after函数          
      注意点：
             1) after函数返回值是一个函数，那么在其执行器中return的是一个函数
             2) after有两个参数，一个是函数执行次数要满足的条件，第二个就是满足次数后要的调用的函数
   3，包括函数：在执行某个函数之前执行若干个函数，在执行某个函数之后执行若干个函数，又称事务函数
      注意点：
             1) 因为不管是执行某函数之前还是之后，都要执行若干个函数，需要把这些函数存储起来，存放到对象里面
             2) 存放这些函数的对象可以有多个，将多个对象可放在数组当中，要想得到每个对象中的函数进行遍历。
   4，发布订阅：
      1) 一般情况下是先发布后订阅，但实际上两者并未有啥关系； 可将它想成按钮的点击事件，在点击之前仅仅是订阅，点击事件发生的同时就是发布啦
      2) 订阅时可以有多个订阅事件函数，我们可将其存放push到容器数组中，在发布时，再将它们遍历出来，并执行订阅函数操作
   5，观察者模式：观察者模式可分为观察者和被观察者（被观察者中存放着观察者） 两者是有关系的 

16，事件与流：
     事件：node是基于事件驱动的  导入events模块
     流：可分为可读流与可写流 
         在http协议创建服务器时，req是请求，是一个可读流
         在http协议创建服务器时，res是响应，是一个可写流

17，http协议：http协议就是计算机与计算机进行交流遵循的规则
    （1）请求：主要包含三个部分
      请求行：里面存在  方法  路径  协议
      请求头：可以浏览器添加；或者自己添加
      请求正文：给服务器的数据
    （2）响应：主要包含三个部分
       状态码：主要有以下几类：以2开头-->到3-->再到4,5
               200 请求成功了
               301 永久重写向 
               302 临时重写向 
               304 缓存
               404 服务器找不到请求的资源  
               401 无仅限访问
               500 服务器挂了
       响应头：一堆的头
       响应正文：服务器给你响应的真实数据
   req请求中可以解析得到url，对于前端的路由：一个url代表一个组件；后端的路由：一个url对应一个资源。
   因为每次改变服务器代码都要求重启服务器，可安装一个模块，叫nodemon，修改完代码后，会自动重启
   安装：> npm i nodemon -g
   使用：> nodemon 文件名

18，node框架：express  koa  基于koa进行二次封装
  1，Express是基于Node.js平台，快速、开放、极简的web开发框架。
   1) express上的路由分两种：
        针对应用级别的路由，在app上进行创建；
        针对router实例对象的路由，在router对象上进行创建；
   2) 创建一个针对应用级别的路由，是分步骤：
        a, 通过express()创建一个app实例
        b, METHOD是一个HTTP的请求方法，如get请求或post请求， app.get(), app.post()
        c, path是服务器上的路径，是url中的路径部分，如 “/”  “/user”
        d,callback当路由匹配成功是要执行一个函数，在这个函数中有两个非常重要的参数，req，res,  req是指incommingMessage, res是指serverResponse

19，那些是get请求？那些是post请求？
  get:直接输入网址；href；src；表单form(method = get)
  post：表单form(method = post)
web:做管理系统与开接口     

服务器渲染：服务器把真实数据渲染到模板里面，然后给客户端返回的就是一个真实数据又称SSR
客户端渲染：使用vue去请求api接口得到json数据，利用v-for将数据渲染出来
前后端分离的基本都是客户端渲染，利用axios拿到数据在vue react中渲染数据
jsp php .net 做一个管理系统  都属于客户端渲染  后端利用模板引擎来将真实数据渲染出来


































































