MVVM原理：当数据改变时，视图更新；视图改变时，数据也会变化。
琢磨MVVM原理：
  1，因为在创建Vue实例vm时直接new上了Vue；且在html文件中是直接script标签引入，不再使用import；所以要在js中创建一个Vue类，但也不需要export将类导出啦！
  2，Vue类中constructor的参数options是html文件Vue实例中传递过去的对象，里面存在着$el参数。
  3，如果对象中$el存在，就能找到上面的HTML模板，将模板中需要替换数据的元素进行替换，又称为编译(编译模板)
  4，当存在$el会调用编译模板（将$el和vue实例传过去，这样就找到模板），要创建编译模板这样一个类
  5，编译之前判断要编译的是否为元素节点（写方法isElementNode(){}）
  6，HTML要渲染出一张网页，要形成一棵DOM树，在DOM树上有两类节点：元素节点和文本节点。
  7，详细的DOM树：最顶部是document而非html，然后是html(<head>(<meta>和<title>(hello文本节点)两大元素节点)和<body>(<div>(world文本节点)元素节点)两大元素节点)；
    其中元素节点和文本节点是在树上，属性节点<charset="UTF-8"><lang="en">不存在于树上
  8，根据节点的属性nodeType来判断是哪种节点：元素节点：nodeType属性返回1；属性节点：nodeType属性返回2。
  9，在constructor中判断el是否为元素节点，是的话就使用它本身，否则就拿到#app对应的一堆元素节点。
  
  10，拿到模板后将模板中的内容一条条挪到内存空间（文档碎片）中，然后再将其在文档碎片中进行替换，将替换后的数据返回到网页
  11，进行替换（编译模板）首先拿到属性节点，判断属性节点是否是以v-打头的指令，通过正则也找到插值表达式对应的节点
  12，封装个对象（工具），里面存在着不同指令对应的不同处理方法
  13，编译元素节点：封装v-model对应的处理方法，给input框上附上value值，将原本的死数据给替换掉
  14，编译文本节点：封装插值表达式对应的处理方法，使用正则将{{}}中的内容替换掉
  
  15，Observer实现数据劫持，把数据变成响应式（给数据添加get()和set()），当数据修改时可以感应到数据修改
  16，在编译元素、文本时，触发相应方法来修改数据，此时会创建watcher()，进入观察者模式
  17，观察者中保存老状态，数据改变更新状态，调用回调函数，根据状态干件事。
  18，Dep类中包含多个Watcher。它是在获取数据时存放watcher的；当数据改变时会通知watcher调用update方法

小结：
  1，Vue类是最高层，它负责整体的调度；当new上它是会调用constructor，且当el存在时会进行模板编译new Compiler；
  2，Compiler类是编译模板；将元素节点转成文档碎片，在内存中编译元素，编译文本，将编译好的渲染到网页上
  3，Observer类是数据劫持；把数据变成响应式（给数据添加get()和set()），当数据修改时可以感应到数据修改啦
  4，Watcher类是观察者；在编译元素、文本时，触发相应方法来修改数据，此时会创建watcher()，调用watcher()
  5，Dep类是存储观察者的；当获取数据时将watcher推到Dep中，数据改变时会通知watcher调用update方法
  6，给input框监听一个input事件


编译模板：去页面中找到带有插值表达式和带有v-指令的节点
数据劫持：将所有数据都变成响应式的。
         获取数据，触发get方法会创建watcher方法；将watcher全部存到Dep中
         修改数据，触发set方法会调用notify方法通知Dep中所有Watcher调用其update方法
update方法会调用回调将数据重新赋值














