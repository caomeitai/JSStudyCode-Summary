数组：定义数组 
    一堆操作数组方法
    再讲一堆方法

-------- 数组的扩展：
ES5数组新增方法:
    1，方法与函数有什么区别？
     方法也是函数，只不过写在对象里面的函数叫方法。
    2，方法的分类?
     方法可分成实例方法和类方法。
     实例方法：挂在对象上的方法；如window.alert(),var obj = {init:function(){}}  obj.init()。
     类方法：直接挂在类上的方法（构造器）；如isArray
    3，数组新增方法
       （1）Array.isArray：判断一个数据是否是数组。
           格式：Array.isArray(arr)   通过console.log()来打印出：true 或 flase。
           Array叫做构造器（本质是一个函数）
        其中arguments（收集实参）不是一个真实的数组，长得虽然像数组，但叫伪数组或者类数组；rest参数是一个真实的数组。
       （2）forEach：对数组进行循环。  （一般我们也会用for对数组进行循环，用for会麻烦一些，因为它要用循环变量）
            格式：数组.forEach( function(item,index,arr){
                  //第一个参数 item : 当前的数组元素。相当于arr[index]；	  
                 //第二个参数 index：数组元素的索引；
                //第三个参数 arr 当前的数组。
             }）;
    item,index,arr这叫形参，形参的命名是任意的，但一般我们写的形参要见名知意，这并不影响结果。更重要的是形参的位置顺序。
    注意点：1.形参是一个回调函数；
            2.修改item的值并不影响原数组（这有个前提，这个item的值是基本数据类型，即如果它是引用数据类型，则这个修改会影响原数组）
            3.不能break；
            4.没有返回值；
            5.如果在回调函数中你不需要用到全部的三个参数，你按顺序去省略。
     （3）map： 逐一处理原数组元素，返回一个新数组。这里的map是JS内置的方法
          格式：arr.map( function(item,index ,arr){
              //item : 当前的数组元素。相当于arr[index]
             //arr 当前的数组
            //index：数组元素的索引；
             return
           } );
        模拟map:原来我们使用的arr.map是js内置的方法，如若使用自己写的可以在Array构造器的原型上创建一个方法
        格式：Array.prototype.MyMap = function(f){    
              var newArray = [];
             //处理老数组中的每一个元素，处理完后，把处理后的元素放到newArray
              for(let i=0; i<this.length; i++){
               newArray.push(f(this[i],i,this))
             }
               return newArray;
            }
    易错点：map也存在着修改item的值并不影响原数组。在return语句时，一般是处理谁就返回谁。新数组因为被处理当然会发生变化，所以在打印时要注意时原数组，而非处理过的新数组
         （这有个前提，这个item的值是基本数据类型，即如果它是引用数据类型，则这个修改会影响原数组）
    什么时候要用map：在我们需要对一个数组进行一些加工，但并不想修改原数组，只是希望在原数组基础上，得到一个新数组。
    （4）filter： 逐一过滤原数组元素，留下符合条件的元素得到一个新数组。
      格式：arr.filter( function(item,index ,arr){
          //item : 当前的数组元素。相当于arr[index]
         //index：数组元素的索引；
        //arr 当前的数组
       return 布尔值；//值为真，表示要留下这个数据。
       } );
    （5）reduce： (累加和的感觉)不断地将前一项和后一项的值进行运算（具体规则是由回调函数决定的，每次的运算会涉及两项）,把前一轮运算的结果作为当前运算的前一项。返回最后结果。
       格式：格式1: 不带初始值： 数组.reduce（function（prev，next）{
	                        return   
                               }）
             格式2: 带初始值： 数组.reduce（function（prev，next）{...}，初值）。
                   其中，function中第一个参数prev表示前一项,第二个参数next表示后一项。当然， 你可以改其它的变量名。
                   reduce中的第二个参数代表初始值，也就是说是加数的第一个值

    （6）some： 只要数组中的某一个元素符合指定的条件，就会返回真，否则返回假。
      格式：数组.some（function（value，index，arr）{ 
	    return  ;//
          }）
    （7）every： 数组中的每一个元素符合指定的条件，就会返回真，否则返回假。
     格式：数组.some（function（value，index，arr）{ 
	   return  ;//
         }）

ES6新增方法:                                                           
    （1）Array.from：这个方法是Array构造器的静态方法，将把类数组对象转成真正的数组。
      格式：格式1：Array.from(类数组对象);
            格式2：Array.from(类数组对象,function(item,index){
	           return ;
                })
    （2）Array.of：将一组值转换为数组。与Array.from功能相似，理解用来创建数组。
     格式：Array.of(数值)；
    （3）find：用于找出第一个符合条件的数组元素。找不到则是undefined 。注意，它是不会返回多个，只找一个，找到了就返回。
               如果你要把所有的满足条件的数组元素都找出来，你应该用filter()。
     格式：arr.find(function(item,index){
		return 条件 ;
           })
    （4）findIndex： 返回第一个符合条件的数组元素的索引。找不到则是-1。
      格式：arr.findIndex(function(item,index){
		return 条件 ;
           })
    （5）includes:判断一个元素是否在一个数组中,返回值是true或者false
     格式：arr.includes(要判断的元素值)
    （6）fill：给数组填充指定值。fill方法用于空数组的初始化非常方便。
        已有数据会被覆盖，fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。
      格式：格式1：arr.fill(值)
            格式2：arr.fill(值,起点，终点) 包括起点，不包括终点

------------ ES6中的解构赋值
1，什么是解构赋值？
   ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
   作用：是对变量进行赋值；变量的值的来源：是数组或者对象；规则：有一定的模式
2，数组的解构赋值：指的是数组下标位置的对应关系
  （1）按下标一一对应地去赋值：因为两边赋值的数组中数据个数一致，就按照从前往后的顺序依照下标给其赋值 
  （2）左右数量不等：那就要从第一个开始对数组进行赋值，在出现没有数据可以为数组赋值时，那么它就是undefined
  （3）跳过部分 ：就是给那个空格不赋值，逃过它，此处为空。
  （4）默认值：就是给数组添加默认值，要是该位置有数可赋，那么它会被覆盖，要是没有值则会按照默认值输出
  （5）嵌套：就是在赋值时出现数组，那就按照格式去对应即可
3，对象的解构赋值
  （1）按属性名的一一对应关系来进行赋值
  （2）本质-按属性名的一一对应关系来进行赋值
  （3）{}只能放键值对，如果键和值是一样，可以只写一个
  （4）对象是属性的无序集合
  （5）解构规则:必须要通过键名进行关联；没有键名就是undefined；对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。
  （6）将现有对象的属性，赋值到某个变量
  （7）沿着原型链进行
  （8）函数参数中的解构赋值
  